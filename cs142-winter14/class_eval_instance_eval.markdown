# Понимание class_eval и instance_eval #

Два Ruby метода кажется вызывают больше путаницы, чем какие либо другие, особенно из-за способа, которым они объясняются. Существуют class_eval и instance_eval. Имена очень похожи и их поведение нелогично(неожиданно). Суть заключается в следюущем:
*	Использование ClassName.instance_eval чтобы определить метод класса (который связан с объектом класса, но не видим экземплярам).
*	Использование ClassName.class_eval чтобы определить инстанс метод ( который применяется во всех экземплярах ClassName).

Чтобы понять почему это так, давайте рассмотрим некоторые примеры, начнем со следюущего кода:

	class MyClass
	  def initialize(num)
	    @num = num
	  end
	end

	a = MyClass.new(1)
	b = MyClass.new(2)

Перед тем как мы присупим к делу, запомните то, что в Ruby все является объектом. Это означает, что классы тоже являются объектами. Когда вы объявляете MyClass, Ruby создаст глобальную переменную с именем MyClass, который является объектом класса для MyClass. Когда вы пишете MyClass.new вы получаете объект класса MyClass и затем вызываете метод new этого объекта, который дает вам новый экземпляр MyClass. Экземпляры являются фактическими объектами класса, которые вы обычно используете. Один класс со множеством экземпляров.

Таким образом, у нас есть два объекта, оба одного класса. Конечно, этот класс не очень полезен потому что он совсем ничего не делает. Нет никакого способа, получить доступ к @num потому что мы не объявили ни одного геттера или сеттера.

	irb> a.num
	NoMethodError: undefined method 'num' for #<MyClass:0x007fba5c02c858 @num="1">

Давайте кратко рассмотрим instance_eval. Что мы можем сделать с ним? Мы можем выполнить код, так еслибы мы были внутри медота определенного объекта, мы вызываем его. Это означает, что мы можем получить доступ к переменным экземпляра ( insance variables) и приватным методам. Давайте выполним выражение в экземплярах MyClass, таким образом мы получим значения обратно.

	irb> a.instance_eval { @num }
	=> 1
	irb> b.instance_eval { @num }
	=> 2
Это замечательно, но будет очень огорчительно сделать это много раз. Давайте определим метод, чтобы сделать это за нас.

	irb> a.instance_eval do
	irb>   def num
	irb>     @num
	irb>   end
	irb> end
	=> nil
	irb> a.num
	=> 1
	irb> b.num
	NoMethodError: undefined method 'num' for #<MyClass:0x007fba5c08e5f8 @num="2">

Ой(Упс)! Мы использовали instance_eval, который только выполняется в контексте одного объекта. Мы объявили метод, но только для конкретного объекта a. Как мы можем создать метод, который будет являться общим для всех объектов этого класса? Возможно на следует объявить метод в объекте класса?
	
	irb> MyClass.instance_eval do
	irb>   def num
	irb>     @num
	irb>   end
	irb> end
	=> nil
	irb> b.num
	NoMethodError: undefined method 'num' for #<MyClass:0x007fba5c08e5f8 @num="2">

Ой, также не работае. Что случилось? Так, мы сделали то же самое как выше, но только для объекта класса! Это означает, мы объявили метод в объекте класса;
это не тоже самое как метод, полученные наследованием объектов этого класса. Это совсем тоже самое, как если бы мы объявили метод в классе с def self.num, который подобен статичному методу класса в Java. Этот метод должен быть вызван как MyClass.num, не a.num, и он не хочет работать тоже:

	irb> MyClass.num
	=> nil

Мы получим здесь nil потому что нет переменых @num в объекте MyClass. Неопределенные переменные имеют значение по умолчанию nil.
Хорошо, тогда каким образом сделать это правильно? Ответом является class_eval:
	
	irb> MyClass.class_eval do
	irb>   def num
	irb>     @num
	irb>   end
	irb> end
	=> nil
	irb> b.num
	=> 2

Ура! Это работает. Мы объявили метод для класса, не для объекта класса и этот метод теперь доступен для все объектов этого класса.
Обратите внимание мы вызвали class_eval в MyClass, ни в одном из экземпляров. Вызов class_eval в экземпляре не будет работать потому что class_eval не является методом произвольных объектов, только объектов класса таких как MyClass. Но вы можете получить класс объектов динамически с использование метода class:

	irb> a.class_eval
	NoMethodError: undefined method 'class_eval' for #<MyClass:0x007fba5c02c858 @num="1">
	irb> a.class.class {}
	=> nil

Другой способ думать об этом, это то, что class_eval равен набору текста внутри оператора class:\

	MyClass.class_eval do
	  def num
	    @num
	  end
	end

поведение точно такое же как в следующем коде:

	class MyClass
	  def num
	    @num
	  end
	end


	



