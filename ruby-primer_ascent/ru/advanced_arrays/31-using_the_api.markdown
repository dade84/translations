# 3.1 Использование API #

## Величайший класс всех времен ##

В значительной степени. Класс Array в Ruby имеет более 100 публичных методов. Мы рассмотрим кучу этих методов и перейдем к некоторым реальным приложениям в предпоследнем разделе.

	(Array.instance_methods - Object.methods).count

Начнем с метода count, который мы использовали выше.

count используетя без аргументов и действует как size или length методы, которые возвращают количество элементов присутствующих в массиве.

	puts [4, 8, 15, 16, 23, 42].count
	puts [4, 8, 15, 16, 23, 42].size
	puts [4, 8, 15, 16, 23, 42].length

count принимает единственный объект как аргумент и возвращает количество элементов массива, у которых элементы равны этому объекту.

	puts [42, 8, 15, 16, 23, 42].count(42)
	puts ["Jacob", "Alexandra", "Mikhail", "Karl", "Dogen", "Jacob"].count("Jacob")
	

count также принимает блок и возвращает количество элементов в массиве для которых блок возвращает true. Найдите количество четных чисел в этом массиве:

	[4, 8, 15, 16, 23, 42].count { |e| e.even? } 

Метод index возвращает индекс указанного объекта. Если дан блок он возвращает индекс первого элемента для которого блок выводит true.

	puts [4, 8 ,15, 16, 23, 42].index(15)
	puts [4, 8, 15, 16, 23, 42].index { |e| e % 2 == 0 }

Метод flatten возвращает  одномерный массив представленного массива. Он рекурсивно отбирает все элементы из внутреннего массива и размещает их во внешнем массиве.

	p [4, 8, 15, 16, 23, 42].flatten
	p [4, [8], [15], [16, [23,42]]].flatten

Можно также ограничить количество уровней когда метода flatten.

	[4, [8], [15], [16, [23,42]]].flatten(1)

comact метод вернет новый массив, удалив все элементы nil.

	p [nil, 4, nil, 8, 15, 16, nil, 23, 42, nil].compact

Напишите метод, который подсчитывает количество элементов массива, которое было передано, только если индекс числа 42 в одномерном представлении массива является 5.

	def zen(array)
	  converted = array.compact.flatten
	  converted.index(42) == 5 ? converted.count : nil
	end		

Метод zip ожидает переменное число аргументов и возвращает массив массивов, который содержит соответствующие элементы из каждого массива. Это поэлементное слияние с основным массивом.

	p [4, 8, 15, 16, 23, 42].zip([42, 23, 16, 15, 8])

Если элементы массива являются аргументам передаваемому zip методу не равны массиву, над которым был вызван метод zip, тогда присваивается nil для неисправной комбинации в последовательности.

slice тоже что и использование литеральной формы [] для извлечения подмассивов.
Он принимает индекс как array[2] или Range, как array[2..7]

	p [4, 8, 15, 16, 23, 42].slice(2)
	p [4, 8, 15, 16, 23, 42].slice(2..5)

join является полезным для объединения всех элементов массива в строку. Можно добавить разделитель между элементам, указав его как аргумент String.

Если вы обратите внимание, join только применяет разделитель между двумя элементами, следовательно, жалея последний элемент.
На самом деле это делает join удобным для обработки информации для отображения.

Напишите метод, который принимает массив в качестве аргумента, отрезав последние два элемента и вернуть строку из этих двух элементов разделенных "|".

	def few2last(array)
	  array.slice[-2..-1].join("|")
	end

shift удаляет первый элемент массива и возвращает его. Сдвигает остальную часть массива в лево так, что второй элемент становится первым элементом, третий элемент становится вторым и т.д.

Можно также указать дополнительный аргумент -- shift(n), который удалит и вернет массив первых n элементов.

	p [4, 8, 15, 16, 23, 42].shift
	p [4, 8, 15, 16, 23, 42].shift(2)

unshift принимает переменное число аргументов и добавляет их в начало массива.

	p [8, 15, 16, 23, 42].unshift(4)
	p [16, 23, 42].unshift(4, 8, 15)

pach возвращает упакованную строку элементов массива преобразованных в соответствующие бинарные последовательности.
Существуют немало указаний, которые вы можете указывать, используйте эту таблицу для справки.

Директива U преобразует в UTF-8 символы. 177 и 8978 коды для символов ± и ? соответственно.

Диррективы зависят от количества элементов массива. Мы указываем U дважды потому что у нас два элемента. Вы можете использовать * для того, чтобы отобрать все элементы.

	p [177, 8978].pack("UU")
	p [177, 8978].pach("U*")



