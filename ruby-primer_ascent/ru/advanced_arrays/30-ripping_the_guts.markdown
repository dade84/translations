# 3.0 Ripping the Guts #

## Lining 'em up #

Вы уже завершили основу introduction to Arrays и готовы погрузиться глубже. Эта глава рассматривает Ruby Array в некоторых деталях, и демонстрирует техники создания и управления массивами.

## Destructurin' ##

Если вы достигли этого места на RubyMonk, вы возможно сталкивались с выражением такое как это.

	zen, life = [42,43]

Это деструктурирование. Мы разделили массив и присвоили его значения переменным zen и life.

Это равнозначно использованию [] или метода at для того, чтобы извлечь значения, давая хорошее сокращение для последовательного разделения массива.

	array = [42,43]
	zen = array[0]
	life = array.at(1)

	puts zen
	puts life

Что произойдет когда один окажется многомерный массивом? Многомерный массив является n-элементным массивом в границах массива. Каждый элемент массива также является массивом из n элементнов. 

	zen, john = [[4,8],[3,16],[23,42,15]]

	p zen
	p john

zen и john ожидаемя отберут первые два внутренних массива.

Также возможно написать функцию и использовать ее как способ моделирования возвращаемого значения. На практике, это редко необходимо. Но итересно знать, что вы можете!

	def zen
	  [42,true]
	end

	x,y = zen

	puts x
	puts y

Все это достаточно ясно. Что еще приятнее, что вы можете использовать их внутри блоков.

	[[1,2,3,4],[42,43]].each {|a,b| puts "#{a} #{b}"}

Это равносильно деструктуризации их вручную внутри блоков место аргументов блока.

	[[1,2,3,4],[42,43]].each do |element|
	  a, b = element
	  puts "#{a} #{b}"
	end

Завершите этот метод для того чтобы вернуть массив. Метод принимает только двумерный массив. Элементы массива, которые возвращает этот метод являются суммой первых двух элементов каждого внутреннего массива в двумерном массиве, который передается.

	def compute(ary)
	  ary.map {|a,b| ((a.nil?) ? 0 : a) + ((b.nil?) ? 0 : b)} if ary
	end

Если вы обратили внимание в примере выше, деструкция массива является немного ограниченной.

	zen, life, more = [42, 43]

	puts zen
	puts life
	p more

В примере выше, more игнорируется и ей просто присвается nil, потому что мы за пределами элементов массива.

## Звездочка ##

В Ruby есть более специальный доступ деструктуризации используя оператор splat(*)(звездочка).

	car, *cdr = [42,43,44]

Это отличается от нашего обычного способа деструктуризации присваиванием как вместо того, чтобы разделить массив на количество переменных присутствующих с левойстороны от присваивания, мы разбиваем массив на число переменных и считывать целиком остаток массива во вторую переменную со звездочкой.

Этот пример может сделать это более ясным.

	*inital, last = [42,43,44]

initial здесь только считывает целиком элементы до 44. Это потому что у нас две переменные и last забирает последнее значение.

Что если мы добавим другую переменную?

	*initial, second_last, last = [42,43,44]

Как ожидалось, initial только считает целиком [42] из массива. Последние два значения присваиваются последним двум переменным.

Измените это выражение для того чтобы считать целиком среднюю часть этого массива используя переменную middle.

	first, *middle, last = [42, 43, 44, 45, 46, 47]

Мы также можем считать целиком или сравнить переменное число аргументов переданных в метод как массив.

	def zen(*args)
	  [args.first, args.last]
	end

	p zen(42, 43, 44, 45, 46)

Вы можете, однако, только установить звездочку последний параметр метода.

Сейчас напишите упражнение для того, чтобы вычислить медиану от множества чисел. Предполагается, что метод median принимает список аргументов, переданных ему.

	def median(*list)
	  return nil if list.empty?
  
	  mid = list.length / 2
	  slist = list.sort
  
	  if slist.length.odd?
	    slist[mid]
	  else
	    (slist[mid - 1] + slist[mid]).to_f / 2.0
	  end
	end

Звездочка не ограничена просто левой стороной. Вы также можете использовать ее с Range, String и преобразовывать их в объекты Array.

	zen = *(1..42)
	str = *"Zen"

Также возможно использовать левостороннюю форму для того, чтобы включить элементы массива в аргументы метода.
	
	def zen(a, b)
	  a + b
	end

	puts zen(*[41,1])

Вы можете использовать их с блоками также.

	[[1,2,3,4], [42,43]].each {|a,*b| puts "#{a} #{b}"}

a первый элемент и b массив, содержащий остальные элементы.

Hash часто создается использую форму массивов, который принимает четное число аргументов, как пары ключ-значение, или напрямую, двумерный массив с парными массивами.

	puts Hash[4,8]
	puts Hash[ [[4,8],[15,16]] ]

Можно использовать звездочку в этой форме для создания hashes.

	ary = [[4,8], [15,16], [23,42]]
	puts Hash[*ary.flatten]

Мы только начали. Мы рассмотрим некоторые хорошие методы, которые предоставляет класс Array в следующем уроке.





