# 0.2 Ќе€вные и €вные блоки #

## ѕреобразование не€вных блоков в €вные ##

»ногда выигрыш производительности вызова не€вных блоков перевешивает необходимость иметь доступ к блоку как конкретному объекту.

Ruby позвол€ет легко преобразовывать блоки из не€вного в €вный и наоборот, но требует специальный синтаксис дл€ этого.

ƒавайте начнем с преобразовани€ из не€вного в €вный.

	def calculation(a, b, &block)
	  block.call(a,b)
	end
	puts calculation(5,5) { |a,b| a + b}

—ейчас другой способ - €вный в не€вный.

	def calculation(a,b)
	  yield(a,b)
	end
	
	addition = lambda {|x,y| x + y }
	puts calculation(5,5,&addition)

“аким образом, из этик двух примеров, получаем простой набор синтаксических правил, чтобы преобразовывать блоки из одной формы в другую:

1. Ѕлок должен быть последним параметром передаваемым методу.
2. ”казание & перед именем последней переменной приводит в действие преобразование.

ƒавайте сделаем упражнение, где вы попробуете это сами.

” нас есть метод, называемый filter, который принимает €вно переданный блок. ћы смотрим в блок, чтобы тот сказал нам следует ли значение из массива прин€ть или отклонить.

ћетод Array#select делает именно это, но требует не€вный блок. ѕопробуй преобразовать €вный блок в не€вный блок и передать его в Array#select.

	def filter(array, block)
 	  return array.select(&block)
	end

ƒавайте, сделаем этот пример более сложным, изменив наш filter метод на блок и сделаем вход€щий блок, который осущестлв€ет фильтрацию передав его не€вно. «десь тебе необходимо преобразовать блок переданный в Filter из не€вной формы в €вную и наоборот.

«вучит усложн€юще? ƒа, преобразование блоков из не€вной формы в €вную и наоборот может сбить с толку. ѕроще сфокусироватьс€ на прохождении тестов и позволить изучающему быть часть этого процесса.

	Filter = lambda do |array, &block|
	  array.select(&block)
	end




