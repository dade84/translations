# 0.1 Yield #

## Переход в блоки ##

Раз уж вы используете блоки, вы узнаете, что самое частое использование предусматривает передачу только одного блока в метод. Этот шаблон чрезвычайно популярен в мире Ruby, и вы станете использовате его постоянно.

У Ruby есть специальное ключевое слово и синтаксис, чтобы сделать этот шаблон более легким в использовании и да, быстрее! Встречайте ключевое слово yield, Ruby реализация наиболее простого способа использования блоков.

Вот пример, который использует основной синтаксис блоков.

	def calculation(a, b, operation)
	  operation.call(a, b)
	end

	puts calculation(5, 6, lambda { |a, b| a + b }) 
	puts calculation(5, 6, lambda { |a, b| a - b })

Как видите, метод calculation принимает два числа и блок, который может выполнить математическую операцию.

Давайте сейчас использовать yield:

	def calculation(a, b)
	  yield(a, b)
	end

	puts calculation(5,6) { |a, b| a + b }
	puts calculation(5,6) { |a, b| a - b }

Как видите, результаты одинаковы(идентичны). Не стесняйтесь чтобы разобраться с примером чтобы лучше прочувстовать(нащупать) новый синтаксис.

Позвольте мне указать, как пример использующий yield отличается от обычного подхода.

* Блок больше не является параметром метода. Блок неявно передается методу - обратите внимание, как он располагается за пределами скобок.
* Yield делает выполнение блока похожим на вызов метода внутри вызова метода вместо того, чтобы явно вызвать блок используя Proc#call.
* Больше нет связи с объектом блока - yield "волшебным образом" вызывает его без
 предусмотрения каких-либо связей объекта.

Обратите внимание что блоки могут принимать неявно методы без параметров. Синтаксис остается таким же.

Вот пример где ни метод ни блок не принимает параметров.

	def foo
	  yield
	end
	foo { puts "sometimes shortcuts do get you there faster" }

## Волшебные блоки ##

Я назвал yield "волшебным" потому что каждое объекто-ориентированное правило в Ruby приостанавливается для этого специального режима вызова блока.

Let's see what rules are bent, and what broken.

1) Yield это не метод

	def foo
	  puts yield
	    puts method(:foo)
	    puts method(:yield)
	end
	foo { "I expect to be heard." }

Как видите, программа взрывается исключением в последней строчке метода. Ясно yield вызывает блок, метод method правильно возвращает объект, который представляет foo как и ожидалось, но затем взрывается на yield. Таким образом, yield на самом деле не метод, хотя выглядит как таковой(оказыватся, это ключевое слово).

2) Objects are abandoned

Все в Ruby является объектом. Где объект, который представлен блоком? Как yield получает доступ к нему и по-видимому вызывает метод call?

Мы не знаем. Как программисты, использующие язык, все что мы можем сказать, что нормальные(обычные) правила были приостановлены.

Мы увидим точно почему эти правила нарушаются позже в этом уроке.

## Он задан? ##

С неявными блоками, сложно быть увереным, что блок действительно передан. Указывая yield когда нет блока может иметь неудачные последствия - вызов исключения (LocalJumpError) с сообщением "блок не задан".

	def foo
	  yield 
	end

Чтобы защититься от этого результата, Ruby предлагает метод block_given? был ли блок передан методу неявно. Сделайте вызов yield зависящим от этого метода, возвращающего true и вам будет хорошо.

	def foo
	  yield if block_given?
	end

## Быстрее, Быстрее! ##

Я уже упоминал, что использование yield ускоряет твой код. Давайте посмотрим как, через следующий пример.

	require "benchmark"
	
	def calculation_with_explicit_block_passing(a,b,operation)
	  operation.call(a,b)
	end

	def calculation_with_implicit_block_passing(a,b)
	  yield(a,b)
	end

	Benchmark.bmbm(10) do |report|
	  report.report("explicit") do
	    addition = lambda { |a,b| a + b }
	    10000.times { calculation_with_explicit_block_passing(5,5,addition)}
	end

	report.report("implicit") do
	  10000.times { calculation_with_implicit_block_passing(5,5) {|a,b| a + b} }
	  end
	end

Таким образом, здесь у нас есть доказательство: нарушая все эти объектно-ориентированные правила дают нам кучу скорости.


## Повторение - мать учения ##

Самые лучшие упражнения это те, которе не требуют разъяснений. Это одно из них. Твоя цель провести все тесты.

	def prettify_it
	  "The result of the block was: #{yield}"
	end




