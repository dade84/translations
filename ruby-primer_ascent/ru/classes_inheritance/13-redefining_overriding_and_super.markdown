# 1.3 Redefining, overriding, and super #

## Замена методов(Redefining methods) ##

Давайте проясним некоторые понятия перед тем как пойдем дальше. Redefining просто предусматривает замену одного метода другим. Оригинальный метод просто...теряется.

Вот пример где ты можешь попытаться это сделать. Вы уже возможно решали его в качестве упражнения - сейчас вы сломаете его.


	class Rectangle
	  def initialize(length, breadth)
	    @length = length
	    @breadth = breadth
	  end
	
	  def perimeter
	    2 * (@length + @breadth)
	  end
  
	  def area
	    @length * @breadth
	  end
	end

	# Add an empty method named perimeter
	# or area and watch tests break
	class Rectangle
	  def perimeter
	  end
	end

Поскольку, почти каждый метод в Ruby может быть переопределен, следует соблюдать большую осторожность особенно с ядром Ruby классов как Object, Array и т.д. Неразумная замена метода может полностью сломать язык. Как показывает практика "Никогда не заменяй методы, вообще, особенно классы поставляемые языком".

Теперь, когда я рассказал как все это опасно, мы оба знаем, что ты хочешь это попробовать. Давайте попробуем это с вашей системой здесь где никому не повредит. Как упражнение, давайте сломаем(разберем) сложение для целых чисел ( Fixnum если быть точным).

Как всегда, пройдем все тесты. Пожалуйста не пробуйте это дома, и особенно на работе.

	class Fixnum
  	  def +(a)
	    42
	  end
	end

## Переопределение методов (Overriding methods) ##

Вы уже это сделали однаждк когда переопределили метод initialize в упражнении гды вы создали класс Square.

Переопределение в контексте классов предполагает переопределение методов в производном классе, который уже определен в суперклассе. В результате метод будет переопределен в производном классе, но в любом случае не будет влиять на метод суперкласса.

В примере ниже, мы создадим класс MyArray - производный класс класса Array и переопределим метод Array#map. Запустите тесты, чтобы увидеть что на Array не повлияли изменения.

	class MyArray < Array 
	  def map
	    'in soviet russia...'
	  end
	end

## Super Powered ##

Широкое применение наследования является то, что переопределение методов в производном классе делать что-то помимо того, что метод суперкласса сделал, а не что-то всецело другое ( как в предыдущих примерах). Это позволяет нам повторно использовать поведение, которое существует в суперклассе, затем изменить в соответствии с потребностями производного класса.

Большинство объектно-ориентированных языков предлагают алгоритм, по которому переопределенный метод может быть вызван переопределяющим методом. Ruby использует ключевое слово super для того, чтобы это произошло. Использование super вызовет тот же самый метод, но как определенный в суперклассе и предоставит вам результат.

В следующем примере, мы определим поведение класса Animal, которое описывает как оно двигается. Сейчас Dolphin является Animal, который может двигаться, но он еще хочет говорить о том как оно двигается.

	class Animal
	  def move
	    "I can move"
	  end
	end

	class Bird < Animal
	  def move
	    super + " by flying"
	  end
	end

	puts Animal.new.move
	puts Bird.new.move

Ваша очередь. Пройдите все эти тесты, и мы завершим с этой главой.

	class Animal
 	 def move
	    "I can move"
	  end
	end

	class Bird < Animal
	  def move
	    super + " by flying"
	  end
	end

	class Human < Animal
	  def move
	    super + " by walking"
	  end
	end  

	class Penguin < Bird
	  def move
	    "I can move by swimming"
	  end
	end

