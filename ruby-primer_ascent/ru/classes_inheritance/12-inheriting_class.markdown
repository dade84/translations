# 1.2 Наследование класса #

## Ваше первое наследование ##

Сейчас мы поняли как работает наследование, давайте делать что-то свое.

Уделите внимание синтаксису оператор < информирует Ruby, что когда создается класс MyArray, ему следует установить класс Array его суперклассом.

	class MyArray < Array
	end

Здесь мы создали наш собственный настоящий класс MyArray, который является подклассом Ruby класса Array. Он наследует все поведение класса Array и таким образом все его методы - и экземпляр класса MyArray работает точно так же как экземпляр класса Array.

Это тем не менее скудный(плохой) пример - MyArray тем не менее не предлагает намдополнительного поведения над классом Array и таким образом не дает нам реальной ценности.

Давайте переключим передачи и заново посетим пример из introduction_to_classes в "Ruby Primer" для того, чтобы сделать урок более полезным.

	class Rectangle
	  def initialize(length, breadth)
	    @length = length
	    @breadth = breadth
	  end

	  def perimeter
	    2 * (@length + @breadth)
	  end
	end

Если вы выполните пример выше, вы заметите, что первый тест говорит о квадрате. Квадрат, по определению, это просто прямоугольник, где все стороны равной длины.

Текущий алгоритм создания квадрата - создание прямоугольника и передача одинаковых значений дважды - это неприятно. Давайте просто создадим наш собственный класс Square, который принимает только один параметр в конструкторе (initialize) вместо двух, но наследует perimeter из Rectangle.

Этот способ, вы получаете лучше синтаксис для квадратов ( Squere.new(3) ) и вы получаете perimeter бесплатно от Rectangle.

	class Rectangle
	  def initialize(length, breadth)
	    @length = length
	    @breadth = breadth
	  end

	  def perimeter
	    2 * (@length + @breadth)
	  end
	end

	class Square < Rectangle
	  def initialize(side)
	    @length = side
	    @breadth = side
	  end
	end


