# 1.1 Понимание наследования #

## Наследуемое поведение ##

Когда классифицируем объекты, достаточно просто начать с основных классов и затем углубиться в создание производных классов, которые более специализированные. Подумайте об этом:

* Integers и Floats оба являются Numbers
* Квадрат является также прямоугольником и оба являются четырехуголниками.
* Машина и мотоцикл являются транспортным средством ( но мотоцикл это не автомобиль).

Эти связи родитель-ребенок между классами часто ссылаются к наследованию, где специализированный класс наследует возможности более главного родителя.

	puts 1.0.is_a?(Float)
	puts 1.0.is_a?(Numeric)

Таким образом, согласно Object#is_a? объект 1.0 является и Float и Numeric (класс, который представляет числа в Ruby).

Это идеальный пример производных классов - здесь Float является производным классом Numeric, таким образом 1.0, который является Float является также Numeric.

Означает ли это, что в Ruby, 1.0 является экземпляром обоих классов Float и Numeric?
Давайте посмотрим сами.

	puts 1.0.class

Конечно, ясно что 1.0 является экземпляром Float. Таким образом как Numeric попал на картинку?

	puts 1.0.class.superclass

Или вывести другим способом:

	puts Float.superclass

## Встречайте суперкласс ##

Метод Class#superclass говорит от какого класса был унаследован любой данных класс. Обратите внимание, что это instance метод Class, а не Object.

Давайте использовать его, чтоб проити дерево наследования Ruby класса Float.

	puts Float.superclass
	puts Numeric.superclass
	puts Object.superclass

Как видите в Ruby Float is a Numeric is an Object is a BasicObject.

Каждый класс в этой цепи наследует поведение класса, который приходит следующим. Все такие цепочки в Ruby оканчиваются классом BasicObject, который полностью пустой, пустой класс без суперкласса. Вызов метода superclass класса BasicObject вернет nil.

Посмотрите как много методов уникальны для 1.0 и как много наследуются от своих предков.

	puts Float.instance_methods.count

Великолепно! Сейчас давайте удалим те методы, который наследуются от Object. Мы пропустим BasicObject потому что у него (как сознательное решение дизайна в Ruby) нет методов совсем.

	puts (Float.instance_methods - Object.instance_methods).count

Так вот, количество сократилось. Сейчас удалим методы наследуемы от Numeric.

	puts (
	  Float.instance_methods - 
	  Object.instance_methods = 
	  Numeric.instance_methods
	).count

Бух! Мы опустились к 13 методам. Как видите, важно понимать наследование иерархии классов чтобы точно знать какие методы у него есть и откуда они пришли.

Ваша очередь, чтобы потренироваться. Как всегда, ваша цель пройти все тесты.

	def is_ancestor?(klass, subclass)
  	current_class = subclass
	  while !current_class.superclass.nil? && current_class != klass
	    current_class = current_class.superclass
	  end
	  current_class == klass
	end

 
