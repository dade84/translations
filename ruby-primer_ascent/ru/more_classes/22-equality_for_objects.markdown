# 2.2 Равенство объектов ##

## Оператор равенства является методом ##
Легко проверить равенство стандартных Ruby объектов таких как строки, числа, массивы и хэши. Вот скорые примеры:

	puts [1,2] == [1,2]
	puts [1,2] == [1,3]

	puts "a" == "xyz"

Массивы, строки и хэши стандартные структуры данных Ruby, оператор сравнения == уже реализован(что значит by Ruby for them). Но как проверить равенство объектов, которые вы определили? Взляните на этот простой класс Item:

	class Item
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
	end

	p Item.new("abcd", 1) == Item.new("abcd",1)

Это неправильный ответ! Оба ответа имеют точно такое же состояние и поведение( из-за того, что они принадлежат одному и тому же классу) и должны были трактоваться как одни и те же объекты.

Это легко исправить. В Ruby, все бинарные операторы(те, которые имеют два операнда) включая == на самом деле явлюятся методами, которая вызывается от параметра с левой стороны оператора. На практике это означает a==b является тем же, что и a.==(b).

Вы все еще в это не верите? Код говорит громче чем слова:

	class Item
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end

	  def to_s
	    "Item (#{@item_name}, #{@qty})"
	  end

	  def ==(other_item)
	    puts "Method == called on #{self} with parameter #{other_item}"
	    false
	  end
	end

	puts Item.new("abcd",1) == Item.new("abcd",1)

Метод == который мы только что объявили всегда возвращает false. Сейчас исправьте его, чтобы return возвращал true если item_name и qty твоего объекта являются тем же объектом, что и объект сравнения.

	class Item
	    attr_reader :item_name, :qty
    
	    def initialize(item_name, qty)
	        @item_name = item_name
	        @qty = qty
	    end
 	   def to_s
	        "Item (#{@item_name}, #{@qty})"
 	   end
	    def ==(other_item)
	      if (@item_name == other_item.item_name) && (@qty == other_item.qty)
	        return true 
	      else
 	       return false
	      end
	    end
	end

	p Item.new("abcd",1)  == Item.new("abcd",1)
	p Item.new("abcd",2)  == Item.new("abcd",1)

Обратите внимание на то, что вы можете переопределить почти все операторы, как этот. Например, если необходимо, чтобы была возможность сложить два элемента у которых одно и тоже имя, вы можете реализовать оператор + в классе Item, который возвращает новый объект item, который содержит общее количество Items. 		

## Равенство объекта, метод eql? и хэш коды ##

Подождите! There is more to object equality. Даже если переопределить == работающий для простых сравнений, имеются некоторые случаи где этого не достаточно.

В следующем примере, мы построим массив копий объектов Item и применим метод uniq. Посмотрим, что случится с uniq:

	class Item
	  attr_reader :item_name, :qty
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
	  def to_s
	    "Item (#{@item_name}, #{@qty})"
	  end
	  def ==(other_item)
	    self.item_name == other_item.item_name && self.qty == other_item.qty	  end
	end

	items = [Item.new)("abcd",1), Item.new("abcd",1), Item.new("abcd",1)]
	p item.uniq

Ожидалось, что Array#uniq возвратит только один элемент поскольку остальные были копиями; но он возвращает все. Ясно что #uniq не работает. Мы переопределили метод == чтобы возвратить true если items одинаковы и мы проверили работу сравнивая item со своей копией. Итак, что же пошло не так?

Короткий ответ в том, что нам не удалось реализовать два других метода, которые являются необходимыми, чтобы получить корректное равенство объекта: eql? и hash методы. Зачем нам нужны эти два сверх метода простому ==?

В Ruby имеется множество операций, которые необходимы чтобы проверить равенство двух объектов. Пока == служит этой цели хорошо, но на самом деле он не быстрый. Для тех операций, которые должны включать большое число проверок равенства(как Array#uniq и просмотр Hash), означает недостаток скорости и становится издержкой. Чтобы обойти эту проблему, Ruby предоставляет hash метод каждому объекту. Он возвращает числовое значение, которое, как правило уникально для каждого объекта.

В следующем примере, мы распечатываем хэш значения для различных объектов. Посмотрите:

	p 1.hash
	p."Hello".hash
	p."Hello!".hash
	p.[1,2,3].hash
	p({:x => 1, :y => 2}.hash)
	
	class Item
	  def initialize(name)
	    @name = name
	  end
	end
	
	p Item.new("ruby").hash
	
Не путайте метод hash, который возвращает хэш код, со структурой данных Hash. Хэш-код объекта короткий идентификатор объекта(и в Ruby всегда числовой). Hash является структурой
данных, который использует хэш коды объектов для быстрого поиска по ключу и таким образом получает имя.

Таким образом, вместо того, чтобы сравнивать два объекта используя ==, который может быть дорогим, когда объекты большие, Ruby использует hash объекта, когда возможно. Будучи
простым числовым значением, это сравнение почти всегда быстрее чем сравнение различных instance variables лежащего в оснве объекта.

Метод Array#uniq, как вы уже догадались, используют результат hash для того чтобы сравнить объекты и идентифицировать копии. Посмотрите как это работает на практике:

	class Item
	  attr_reader :item_name, :qty
	  
	  def initialize(item_name, qty)
	    @item_name = item_name
		@qty = qty
	  end
	  
	  def to_s
	    "Item (#{@item_name}, #{@qty})"
	  end
	  
	  def hash
	    self.item_name.hash ^ self.qty.hash
	  end
	  
	  def eql?(other_item)
	    puts "#eql? invoked"
		@item_name == other_item.item_name && @qty == other_item.qty
	  end
	end

	p Item.new("abcd",1).hash
	items = [Item.new("abcd",1), Item.new("abcd",1), Item.new("abcd",1)]
	p items.uniq
	
Array#uniq не работает правильно для объекта item. Это потому мы реализовали два метода: hash и eql?.

Что делает метод hash? Используется оператор ^, который является бинарным XOR. hash метод возвращает результат XOR всех instance variables для того, чтобы определить состояние объекта. Это обеспечивает то, что когда меняется состояние объекта, хэш код также изменяется. Различные хэш коды для различных объектов являются чрезвычайно востребованным свойством хэш кодов через которые операции над коллекциями становятся быстрее.

Также введен метод eql? в примере выше. На самом деле он был вызван дважды Array#uniq для того, чтобы проверить равенство элементов массива. Даже если мы используем == для того, чтобы проверить равенство объектов, процедуры как Array#uniq используют eql? вместо этого. Это означает, что мы должны реализовать метод eql? всякий раз, когда мы переопределяем ==. Во многих случаях, эти два метода будут одинаковыми, таким образом вы можете реализовать фактическое сравнение в одном методе и иметь другой метод где просто вызывать его.

Подведем итог, если вы когда-либо переопределяете любые из этих методов ==,eql?,hash вы должны переопределить остальные.

## Заключение равенство объектов в Ruby ##

Здесь заключительно упражнение этого урока. У меня есть Item класс, который хранит наименование, количество и цену. Вам нужно реализовать методы равенства для этого объекта. Запомните, вы должны:

* Определить метод ==, который сравнивает состояние твоего объекта с другим и возвращает логиеское значение.
* Определить метод eql?, который просто вызывает == для того, чтобы осуществлять фактическое сравнение.
* Определить метод hash, который возвращает результат XOR(используя оператор ^) hash всех этих instance variables, которые вместе определяют состояние объекта.

	class Item
	  attr_accessor :item_name, :quantity, :supplier_name, :price
	  def initialize(item_name, quantity, supplier_name, price)
	    @item_name = item_name
	    @quantity = quantity
	    @supplier_name = supplier_name
	    @price = price
	  end 
	  
	  def ==(other_item)
	    self.item_name == other_item.item_name && self.quantity == other_item.quantity && self.price == other_item.price
	  end
  
	  def eql?(other_item)
	    self.==(other_item)
	  end
  
	  def hash
	    self.item_name.hash ^ self.quantity ^ self.price
	  end
	end

