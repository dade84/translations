# 2.2 Равенство объектов ##

## Оператор равенства является методом ##
Легко проверить равенство стандартных Ruby объектов таких как строки, числа, массивы и хэши. Вот скорые примеры:

	puts [1,2] == [1,2]
	puts [1,2] == [1,3]

	puts "a" == "xyz"

Массивы, строки и хэши стандартные структуры данных Ruby, оператор сравнения == уже реализован(что значит by Ruby for them). Но как проверить равенство объектов, которые вы определили? Взляните на этот простой класс Item:

	class Item
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
	end

	p Item.new("abcd", 1) == Item.new("abcd",1)

Это неправильный ответ! Оба ответа имеют точно такое же состояние и поведение( из-за того, что они принадлежат одному и тому же классу) и должны были трактоваться как одни и те же объекты.

Это легко исправить. В Ruby, все бинарные операторы(те, которые имеют два операнда) включая == на самом деле явлюятся методами, которая вызывается от параметра с левой стороны оператора. На практике это означает a==b является тем же, что и a.==(b).

Вы все еще в это не верите? Код говорит громче чем слова:

	class Item
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end

	  def to_s
	    "Item (#{@item_name}, #{@qty})"
	  end

	  def ==(other_item)
	    puts "Method == called on #{self} with parameter #{other_item}"
	    false
	  end
	end

	puts Item.new("abcd",1) == Item.new("abcd",1)

Метод == который мы только что объявили всегда возвращает false. Сейчас исправьте его, чтобы return возвращал true если item_name и qty твоего объекта являются тем же объектом, что и объект сравнения.

	class Item
	    attr_reader :item_name, :qty
    
	    def initialize(item_name, qty)
	        @item_name = item_name
	        @qty = qty
	    end
 	   def to_s
	        "Item (#{@item_name}, #{@qty})"
 	   end
	    def ==(other_item)
	      if (@item_name == other_item.item_name) && (@qty == other_item.qty)
	        return true 
	      else
 	       return false
	      end
	    end
	end

	p Item.new("abcd",1)  == Item.new("abcd",1)
	p Item.new("abcd",2)  == Item.new("abcd",1)

Обратите внимание на то, что вы можете переопределить почти все операторы, как этот. Например, если необходимо, чтобы была возможность сложить два элемента у которых одно и тоже имя, вы можете реализовать оператор + в классе Item, который возвращает новый объект item, который содержит общее количество Items. 		

## Равенство объекта, метод eql? и хэш коды ##

Подождите! There is more to object equality. Даже если переопределить == работающий для простых сравнений, имеются некоторые случаи где этого не достаточно.

В следующем примере, мы построим массив копий объектов Item и применим метод uniq. Посмотрим, что случится с uniq:

	class Item
	  attr_reader :item_name, :qty
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
	  def to_s
	    "Item (#{@item_name}, #{@qty})"
	  end
	  def ==(other_item)
	    self.item_name == other_item.item_name && self.qty == other_item.qty	  end
	end

	items = [Item.new)("abcd",1), Item.new("abcd",1), Item.new("abcd",1)]
	p item.uniq

Ожидалось, что Array#uniq возвратит только один элемент поскольку остальные были копиями; но он возвращает все. Ясно что #uniq не работает. Мы переопределили метод == чтобы возвратить true если items одинаковы и мы проверили работу сравнивая item со своей копией. Итак, что же пошло не так?

Короткий ответ в том, что нам не удалось реализовать два других метода, которые являются необходимыми, чтобы получить корректное равенство объекта: eql? и hash методы. Зачем нам нужны эти два сверх метода простому ==?

В Ruby имеется множество операций, которые необходимы чтобы проверить равенство двух объектов. Пока == служит этой цели хорошо, но на самом деле он не быстрый. 


