# 2.0 Переменные экземпляра и средства доступа #

## Переменные экземпляра ##

Кратко рассмотриваются переменные экземпляра в уроке The RubyMonk RubyPrimer:Building your own class.

Там на самом деле не так много переменных экземпляра. Они привязаны к экземпляру класса и вместе формируют то, что мы называем состояние объекта. Каждый экземпляр класса имеет различное множество переменных экземпляра. Давайте посмотрим, как это работает:

	
	class Item
	  def initialize(item_name,quantity)
	    @item_name = item_name
	    @quantity = quantity
	  end

	  def show
	    puts @item_name
	    puts @quantity
	  end
	end

	Item.new("tv",1).show
	Item.new("fridge",1).show

Как видно из примера выше, Item.new создает новый объект - экземпляр класса Item. Переменные экземпляра, в примере выше, @item_name и @quantity приставлен спереди символ @. Это предусмотрено в Ruby - если ваши переменные не начинаются с @, считается что это локальная переменная.

В чем разница между локольными и переменными экземпляра? Я покажу на примере. Обратите внимание что следующий пример собирается вызвать ошибки и это нормально.

	class Item
	  def initialize(item_name, quanitity)
	    @item_name = item_name
	    @quantity = quantity
	    supplier = "Acme corp"
	  end
 	
	  def show
	    puts @item_name
	    puts @quantity
	    puts supplier
	  end
	end

	Item.new("tv",1).show

Сообщение об ошибке должно информативным, каким образом используется локальная переменная supplier. Локальная переменная доступна только внутри метода, в котором определена. Нет общего доступа всему объекту. В термирологии языка программирования, говорим, что это "область видимости" локальной переменной, которая привязана к методу в котором определена.

Разница между областью видимости локальной переменной и переменной экземпляра: переменная экземпляра связана с конкретным экземпляром класса. Связывая себя с целым объектом, переменная экзепляра становится каждому методу объекта.

## Методы Getter и Setter ##

Объект не может существовать обособленно. Он должен сообщить свое состояние другому объекту в некотором месте. Тем не менее, только собственные методы объекта могут получить доступ к переменным экземпляра. Таким образом, можно иметь методы,известные как "getter", единственной целью которых является вернуть значение определенной переменной экземпляра. Давайте посмотрим на пример:

	class Item
	  def initialize(item_name, quantity)
	    @item_name = item_name
	    @quantity = quantity
	  end

	  def item_name
	    @item_name
	  end
	end

	item = Item.new("tv",1)
	puts item.item_name

Getter-ом тут являетс метод item_method. Посмотрите, это было просто.
Имея явно определенный геттер метод, обеспечивает то, что объект всегда под контролем того, как состояние становится публичным. Позвольте мне дать вам простое упражнение, чтобы показать почему это является замечательной вещью.

Мы вернемся еще раз к нашему классу Item для этого упражнения.  У Item класса есть новое поле: color. Но тот факт, что мы сохраняем цвет как отдельный атрибут внутри нашего объекта не должно влиять на то, как используется наш объект. В этом упражнении, вы должны определить метод description, getter, который возвращает строку, которая содержит описание и цвет объекта.

	class Item
	  def initialize(description, color)
	    @description = description
	    @color = color
	  end
  
	  def description
	    @description + @color
	  end
	end

Мы уже говорили о доступе к содержимому переменной экземпляра через геттер методы. Как извне изменить значение переменной экземпляра? Вот где сеттеры будут ползены.

Чтобы выполнить выражение item.color = 'red', Ruby вызывает метод Item#color= и передает ему значение 'red'. Это означает, что все сеттер методы оканчиваются знаком = в своих именах. Например метод color=.

В следующем упражнении, я определил заготовку сеттер метода quantity=. Вы должны реализовать его таким образом, чтобы переменная экземпляра @quantity являлось установленным параметром new_quantity.

	class Item
	  def initialize(item_name, quantity)
	    @item_name = item_name
	    @quantity = quantity
	  end
  
	  def quantity=(new_quantity)
	    @quantity = new_quantity
	  end
  
	  def quantity
	    @quantity
	  end  
	end

	item = Item.new("a",1)
	item.quantity = 3
	p item.quantity


## Сделаем жизнь проце через attr_accessors

Ruby предоставляет пару методов чтобы сделать жизнь проще, когда объявляем геттеры и сеттеры для своего объекта.
Позвольте начать с примера метода attr_reader:

	class Item
	  attr_reader :item_name

	  def initialize(item_name)
	    @item_name = item_name
	  end
	end

	item = Item.new("agragarok")
	p item.item_name

Метод attr_reader определяет метод чтения для вас. Это краткая форма соглашения, которую вы можете использовать, когда ваш геттер просто возвращает значение переменной с одинаковым именем.

Имеется подобный метод attr_writer, который как вы можете ожидать, определяет метод сеттер, который устанавливает значение переменной экземпляра с тем же именем, что и сеттер. Почему бы вам не попробовать использовать attr_writer для того, чтобы реализовать метод сеттер для переменных экземпляра description и color в следующем упражнении?

	class Item
	  attr_writer :description, :color
  
	  def initialize(description, color)
	    @description = description
	    @color = color
	  end
	end

Сейчас ты знаешь, что такое методы геттер и сеттер и как исользовать attr_reader и attr_writer как краткую форму для их определения.

В некоторых случаях возможно захочется предоставить оба метода и геттер и сеттер для переменной экземпляра. Вместо того, чтобы вызывать attr_reader и attr_writer для той же переменной, вы можете использовать другой метод, attr_accessor, который определит оба метода и геттер и сеттер.

Подеведем итог:

* attr_reader :description определит def description; @description; end
* attr_reader :description даст нам def description=(new_description); @description = new_description; end
  и
* attr_accessor :description равзнозначен attr_reader :description; attr_writer :description

Ruby ограничивает доступ к переменным экземпляра кроме как через геттеры и сеттеры, которые не являются ограниченим языка, а является намеренным ограничением. Это накладывается так, что Ruby код следуюет передовой объектно-ориентированной практике. Геттер и Сеттеры на самом деле, это способы чтобы обойти сами ограничения - что говорит нам, что необходимо быть немного осторожными при их использовании. Я не буду тут вдаваться в подробности, но мы будем говорить об этом в нашей будущей книке "Объектно ориентированное программирование в Ruby". Тем не менее, Я реккомендую вам просмотреть статью Allen Holub, которые рассказывает об объектно-ориентированном программировании и как геттеры и сеттеры могут быть не очень хороши для вашего кода.

