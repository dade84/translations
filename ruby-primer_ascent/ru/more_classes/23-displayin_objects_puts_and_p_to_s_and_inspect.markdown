# 2.3 Отображение объектов: puts и p, to_s и inspect #

## puts и p ##

Разницу между этими двумя методами лучше всего объяснить через пример:

	class Item
	  def inspect
	    "Result of inspect"
	  end
	end

	puts Item.new
	puts Item.new.to_s
	p Item.new

puts в основном выводит результат применения метода to_s над объектом, в то время как p выводт результать применения метода inspect.

## ispect vs to_s ##

Еще один пример:

	class Item
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
	end

	item = Item.new("a",1)
	puts item
	p item

Как видно, puts печатате имя класса объекта наряду с числом отображаемым в hex. Это число в зависимости от положения объекта в памяти, но мы редко находим ему применение. Зато p печатает имя класса и все instance variables объекта. Это может быть очень полезным при отладке.

Вышестоящий пример иллюстрирует поведение по умолчанию методов p и puts. Но будут случаи, когда вы захотите настроить, что этим методам отображать. Это легко сделать переопределив метод to_s.

	class Item
	  attr_accessor :item_name, :qty
	  def initialize(item_name, qty)
	    @item_name = item_name
	    @qty = qty
	  end
  
	# override 'to_s' here  
	  def to_s
	    "Item: (#{item_name} #{qty})"
	  end  
	end

	item = Item.new("a",1)

	puts item
	p item

Вы обратили внимание на то, что вывел методы p и puts стали такими же как в примере выше? Это потому что если переопределить метод to_s объекта, Ruby будет трактовать его как результат метода inspect также, пока вы не переопределите inspect отдельно. Это как правило желаемое поведение, но вы можете реализовать метод inspect сами если вам нужны другие результаты для каждого метода.

Также, Это вообще самая лучшая практика, переопределять метод to_s в своих классах, чтобы он мог вернуть значимый результат, который адаптирован для каждого класса.

