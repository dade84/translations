# Ruby: создание Hash из Arrays #

Ruby имеет очень красивую выразительность и предлагает замечательную стандартную библиотеку. Это очень помогает, когда имеешь дело со структурами данных. Особенно когда ты должен сконвертировать, слить или объединить Arrays и Hashes. Эта публикация(post) показывает только маленький пример из большой области возможностей.

## Цель ##

Одна вещь, на которую мы возможно натыкаемся когда создаем структуры данных является задача создать Hash из двух массивов где один массив содержит ключи и другой значения, являющегося результатом Hash. Основывая на нашем примере массивов, результат может выглядеть следующим образом:

	{
	  "Veren" => "reading",
	  "Kiana" => "swimming",
	  "Naya"  => "painting"
	}

Или даже:

	{
	  "Verena" => "rock",
	  "Kiana" => [
	    [0] "folk",
	    [1] "disco"
	  ],
	  "Naya" => "metal"
	}

Следующий раздел описывает как мы можем создать эти структуры данных.

## Данные ##

У нас есть три простых массива со следующей структурой:

	names = %w(Verena Kiana Naya)
	[
	  [0] "Verena",
	  [1] "Kiana",
	  [2] "Naya"
	]

	hobbies = %w(reading swimming painting)
	[
	  [0] "reading",
	  [1] "swimming",
	  [2] "painting"
	]

	music = ['rock', %w(folk disco), 'metal']
	[
	  [0] "rock",
	  [1] [
	    [0] "folk",
	    [1] "disco",
	  ],
	  [2] "metal"
	]

Эти массивы являются основой для всех последующих шагов для того чтобы создать наш Hash.

## Объединение данных с помощью Array#zip метода ##

Из документации
	>Converts any arguments to arrays, then merges elements of self with
	> corresponding elements from each argument.
	>
	> Преобразует любые аргументы в массивы, затем сливает свои элементы с соответствующими элементами с каждым аргументом.

Таким образом используя наши структуры данных, мы можем делать что-то такое:

	names.zip(hobbies)
	[
	  [0] [
	      [0] "Verena",
	      [1] "reading"
	  ],
	  [1] [
	      [0] "Kiana",
	      [1] "swimming"
	  ],
	  [2] [
	      [0] "Naya",
	      [1] "painting"
	  ]
	]

Как видите, Array#zip создает новый массив из наших двух массивов name и hobbies. Результирующий массив состоит из пар из name[0] -> hobbies[0], name[1] -> hobbies[1] и т.д. Если не будет найдено соответствующего значения, nil будет вставлен в результирующий массив.

Метод zip является очень полезным для создания структур данных, как мы увидим когда мы будем создавать Hash.

## Одномерный(flat) массив из вложенного массива с Array#zip ##

Из документации
	
	> Returns a new array that is a one-dimesional flattening of self(recursively).
	> Возвращает новый массив, который является одномерным массивом с удаленим иерархической структуры самого себя.

Результирующий массив массивов, созданный с Array#zip метода, все еще не находится в правильной форме для того, чтобы быть брошенным в наш результирующий Hash. Мы должны сконвертировать его в одномерный массив потому что позже мы создадим пары ключ-значение как это:

	key0 = Array[0]
	value1 = Array[1]
	key1 = Array[2]
	value1 = Array[3]

Я думаю у вас появилась идея. Array#flatten поможет завершить нашу работу. Это просто как :

	name.zip(hobbies).flatten
	[
	  [0] "Verena",
	  [1] "reading",
	  [2] "Kiana",
	  [3] "swimming",
	  [4] "Naya",
	  [5] "painting"
	]

Это было просто. Сейчас давайте посмотрим как мы создадим конечный Hash в следующей секции.

## Достижение цели: создание Hash из Arrays ##

Мы почти закончили. В предыдущей секции мы видели, как создать одномерный(flattened) массив.
Этот массив имеет правильную форму для того, чтобы просить его в наш Hash. Давайте сделаем это:

	Hash[names.zip(hobbies).flatten]
	(irb):47: warning: wrong element type String at 0 (expected array)
	(irb):47: warning: ignoring wrong elements is deprecated, remove them explicitly
	(irb):47: warning: this causes ArgumentError in the next release
	(irb):47: warning: wrong element type String at 1 (expected array)

В чем дело? Это не ожиданный результат. Почему так?

Проблема в том, что Hash ожидает получить список аргументов. И тут вступает в действие оператор splat *. Можно сконвертировать список в группу параметров и можно заполнить массив этой группой параметров. Ниже мы посмотрим на некоторые примеры.

### Преобразование Hash'а в Array ###

	hash = *{'Andy' => 'Daddy'}
	[
	  [0] [
	      [0] "Andy",
	      [1] "Daddy"
	  ]
	]

### Преобразование (flat) Array в Hash ###
	Hash [*n.flatten]
	{
	  "Andy" => "Daddy"
	}

Интересно проанализировать результат с помощью метода class:

	hash = { 'Andy' => 'Daddy'}.class
	=> Hash
	
	hash = *{'Andy' => 'Daddy'}.class
	=>[Hash]


Как можно увидеть, второй является Hash в списке(Array).

Вы также можете делать другие клевые вещи с оператором splat. Пожалуйста посмотрите http://4loc.wordpress.com/2009/01/16/the-splat-operator-in-ruby/ детально.

## Но сейчас: результирующий Hash ##

После мы поймем почему произошла ошибка и узнаем как ее обойти, наконец мы можем создать свой Hash:

	Hash[*names.zip(hobbies).flatten]
	{
	  "Verena" => "reading",
	  "Kiana" => "swimming",
	  "Naya" => "painting"
	}

Это тот результат, который мы ожидали. Здоров. Но что если структура hobbies имела бы вложенные массивы? Давайте посмотрим что случится, когда мы используем массив music вместо массива hobbies:

	Hash[*names.zip(music).flatten]
	ArgumentError: odd number of arguments for Hash
	    from (irb):79:in `[]'
	    from (irb):79
	    from /Users/andwen/.rvm/rubies/ruby-2.0.0-p353/bin/irb:12:in 
	`<main>'

Хм - это не работает. Ruby не знает что делать с не flat структурой данных music. Нам нужно создать Hash немного по другому:

	result = {}
	Hash[names.zip(music).each { |a,b| result[a] = b }]
	{
	 	"Verena" => "rock",
	        "Kiana" => [
	           [0] "folk",
	           [1] "disco",
	        ],
	        "Naya" => "metal"
	}

Цель достигнута. Пожалуйста обратите внимание, что это работае для массивов, глубиной вложенности равной единице. Я оставлю это вам, для того, чтобы вы также нашли решение для глубины вложенности равной n.

## Дальнейшая информация для массивов и хэшей ##

Иметь дело с массивами и хэшами это ежедневное дело разработчиков. Это конечно также расчитано на Rubyist. Вам следует определенно погрузиться в документацию для Array и Hash классов включенных в стандартную библиотеку Ruby.

## Заключение ##

В этой публикации мы рассмотрели как преобразовать два Массива с простыми структурами данных в Hash со структурой key-value. Очень полезно иметь дело с данными и мы видели, что Ruby предлагает хорошее решение для того, чтобы обработать эти задачи.



http://andywenk.github.io/2014/06/27/ruby-create-a-hash-from-arrays/




