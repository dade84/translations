# 1.2 Расширенные операции со строками #

## Разделение строк ##

В этом уроке мы будем рассматривать жизненно важные методы, которые предоставляет объект String для управления строками.

Разделение строк определенного слова, символ управляющей последовательности или пробел чтобы получить массив подстрок наиболее часто используемая техника. Метод Ruby String API предоставляет для этого String#split. Давайте начнем с разделения строки ниже на пробелы '', чтоб получить коллекцию слов в строке. Это может создавать огромную разница в потреблении памяти, если вы действительно массово управляете строками. Измените код выше на '<<' и посмотрите все тесты, пройдя их снова.


	Fear is the path to the dark side'.split(' ')

Можно фактически управлять строками сочетая String#split и Регулярные Выражения. Мы рассмотрим Регулярные выражения, их формы и использование дальше внизу упражнения.

Возможно также разделить строки на новые строки и обработать большое количество данных в форме CSV.

## Объединение строк ##

В Ruby вы можете создать новую строку объединив две строки вместе как в большинстве других языков.

	'Ruby' + 'Monk' #=> RubyMonk

Ruby часто предоставляет больше одного способа чтобы сделать одну и ту же вещь. Буквенный и выразительный метод для объединения String это String#concat.

	"Ruby".concat("Monk") #=> RubyMonk

Давайте попробуем более широко используемый псевдоним. Вы можете использовать '<<' также как '+', но в этом случае объект String 'Monk' будет добавлен в конец к объекту, представленный самим 'Ruby'. В первом случае используя '+' , сама строка не изменяется, т.к. создается третья строка 'RubyMonk'.  


## Замена подстроки ##

Ruby String API предоставляет сильную поддержку для поиска и замены в строках. Мы можем искать подстроки или использовать Regex. Давайте сначало попробуем свои силы в чем-нибудь простом. Это то, как мы будем заменять 'I' на 'We' в данной строке:

	"I should look into your problem when I get time".sub('I', 'We')  #=> "We should look into your problem when I get time"

Метод выше только заменяет первое вхождение выражения, которое мы ищем. Для того чтобы заменить все вхождения мы можем использовать метод, называемый gsub, у которого глобальная область видимости.

	"I should look into your problem when I get time".gsub('I', 'We') #=> "We should look into your problem when We get time"


Если вы не сталкивались с термином Regular Expression раньше, сейчас время для знакомства. Regular Expressions или RegExs краткое и гибкое значение для соответствия определенных символов, слов или шаблонов символов. В Ruby вы указываете RegEx вставив их между пары косых черточек ( / ). Сейчас давайте рассмотрим пример, который заменяет все гласные числом 1:

	'RubyMonk'.gsub(/[aeiou]/,'1')  #=> 'R1byM1nk'

Вы могли бы заменить все строчные символы числом '0' в следующей проблеме?

	'RubyMonk Is Pretty Brilliant'.gsub(/[A-Z]/,'0')
        'RubyMonk Is Pretty Brilliant'.gsub(/[RMIPB]/,'0')


## Поиск подстроки используя RegEx##

Мы охватили искусство поиска позиции подстроки в предыдущем уроке, но как мы будем обрабатывать эти случаи когда мы не точно не знаем, что мы ищем? Вот где Regular Expression будут кстати. Метод String#match преобразует шаблон в RegEx (если он еще не преобразован) и затем вызывает его метод match на целевом String объекте. Вот как найти символы из String, которые находятся рядом с пробемлом:

	'RubyMonk Is Pretty Brilliant'.match(/ ./) #=> I

Как вы могли видеть в результате, метод просто вернул первое совпадение вместо того, чтобы вернуть все совпадения. Для того чтобы найти следующие совпадения, мы можем передать второй аргумент в метод match. Когда второй параметр присутствует, он указывает позицию в строке откуда начать. Давайте найдем второй символ в строке 'RubyMonk Is Pretty Brilliant' которому предшествует пробел, который должен быть 'P'.

	'RubyMonk Is Pretty Brilliant'.match(/ ./,10) #=> P
        

Все сложные варианты использования этого метода вовлечены в более продвинутые Regular Expressions, которые за пределами данного урока.
Тем не менее, если вы когда-нибудь решите реализовать синтаксический анализатор, String#match может оказаться очень хорошим другом!

























