# 9.2 Использование класса File #

## Открытие и закрытие ##

В прошлом уроке, где мы использовали IO.sysopen и IO.new для того, чтобы создать новый объект IO, здесь мы будем использовать класс File. Обратите внимание, на то, как это просто!

(Обратите внимание, что file.inspect вернет FakeFS::File это не настоящий объект File потому что в противном случае ваш "friend-list.txt" будет конфликтовать с другим rubymonk пользователем "friend-list.txt". Не беспокойтесь - его поведение как у настоящего объекта File. Посмотрите сами! File#read показан как пример.)

	mode = "r+"
	file = File.open("friend-list.txt", mode)
	puts file.inspect
	puts file.read
	file.close


mode это строка которая указывает каким способом файл должен быть открыт. Здесь мы используем r+, который открывает файл в режиме чтение-запись, начиная с начала. w открывает его только в режиме записи, обрезая сущевующий файл. Вы можете посмотреть на все возможные режимы здесь.

Стоит отметить то, что существует множество способов, чтобы открыть файлы в Ruby. File.open также принимает необязательный блок, который автоматически закротеся, когда вы завершите с файлом, который открыли.

	what_am_i = File.open("clean-slate.txt", "w") do |file|
	  file.puts "Call me Ishmael."
	end

	p what_am_i

	File.open("clean-slate.txt", "r") {|file| puts file.read }


## Чтение и запись ##

Сейчас мы посмотрим на некоторые методы для того, чтобы читать из потока I/O. В этих примерах, наш I/O поток это файл, но запомните: как описано в предыдущем примере, файлы ведут себя также как любой другой поток I/O.

метод File#read принимает два необязательных аргумента: length, количество байтов, которое необходимо считать из потока и буфер, где вы можете предоставить String буфер, который будет заполнен данными файла. Этот буфер иногда полезен для повышения производительности, когда происходит переобор файла, как повторное использование уже инициализированных строк.

	file = File.open("master", "r+")

	p file.read
	file.rewind # try commenting out this line to see what happens!
        	    # can you guess why this happens?

	buffer = ""
	p file.read(23, buffer)
	p buffer

	file.close


Вы можете предположить почему мы должны использовать File#rewind до второго вызова File#read? Ничего, что вы не можете или не уверенны. Причина на самом деле из-за внутренней обработки файлов в Ruby. Когда читаем из объекта File, Ruby отслеживает вашу позицию. При этом, вы можете прочитать строку, страница или произвольную часть за раз без пересчета, где вы остановились после последнего чтения.

Если все еще не ясно, попробуйте сначало изменить file.read на file.read(16) и затем закоментировать file.rewind снова. Позиция в файле должна быть очевидной из второго чтения.

File#seek укрепляет эту идею еще дальше. Вы можете "стремиться" к отдельному байту в файле, для того чтобы сказать Ruby, где ты хочешь начать читать файл. Если ты хочешь отдельное множество байт из файла, ты можешь передать параметр length в File#read, чтобы отобрать число байт из твоей новой начальной точки.

	p File.read("monk")

	File.open("monk") do |f|
  	  f.seek(20, IO::SEEK_SET)
  	  p f.read(10)
	end

readlines возвращает массив всех строк открытого потока IO. Вы можете, снова, при желании ограничить число строк и/или вставить текущее ограничение между каждой из этих строк.

	lines = File.readlines("monk")
	p lines
	p lines[0]


Чтобы писать в поток I/O, вы можете использовать IO#write (или, в нашем случае, File#write) и подавать строку. Возвратится количество байт, которое было записано. Попробуй вызвать этот метод, который пишет "Bar" в файл под названием disguise.

	File.open("disguise", "w+") do |f|
	  f.write("Bar")
	  puts f.read()
	end


