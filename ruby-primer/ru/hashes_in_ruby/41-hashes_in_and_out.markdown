# 4.1 Hashes, внутри и снаружи #

## Перебор внутри Hash ##

Можно использовать метод each для перебора всех элементов Hash. Тем не менее, в отличие от Array#each, когда вы перебираете Hash используя each, передаются два значения в блок: ключ и значение каждого элемента.

Давайте посмотрим как можно использовать каждый метод для того, чтобы вывести на экран меню ресторана.

	restaurant_menu = {"Ramen" => 3, "Dal Makhani" => 4, "Coffe" => 2 }
	restaurant_menu.each do |item, price|
	  puts "#{item}: $#{price}"
	end

В ресторане все хорошо, но он вынужден повышать цены из-за увеличения расходов. Используте метод each для увеличения ценыкаждого элемента в хэше restaurant_menu на 10%.

Запомните: в предыдущем примере мы только отобразили на экране ключи и значения каждого элемента хэша. Но в этом упражнении, вы должны изменить хэш и увеличить значение каждого элемента.

	restaurant_menu = { "Ramen" => 3, "Dal Makhani" => 4, "Coffee" => 2 }
	# write the each loop here. 
	restaurant_menu.each do |item, value|
  	  restaurant_menu[item] = value + (value * 0.1)
	end

В идеале, любое преобразование коллекции( как в примере выше) должна производится новая коллекция с неизменным оригиналомсоздаваемый код легче понимать и управлять.

Тем не менее, скорость и ограничения памяти часто (и обычно по ошибке) превосходят удобство сопровождения и такой подход как выше используется очень часто. 

## Извлечение ключей и значений из Hash ##

У каждого Hash объекта есть два метода: keys и values. Метод keys возвращает массив всех ключей в Hash. Аналогично значения возвращают массив только значений.

Попробуйте получить массив всех ключей в хэше restaurant_menu:

	restaurant_menu = { "Ramen" => 3, "Dal Makhani" => 4, "Coffee" => 2 }
	# your code here    
	restaurant_menu.keys

## Современнее, быстрее ##

Имеется несколько малоизвестных сокращений для создания новых хэшей. Они предоставляют немного другое соглашение. Предыдущие два примера формируют хэш напрямую из уже существующих пар ключ-значение. Первый просто устанавливает значение по умолчанию для всех элементов хэша. Давайте сначало взглянем на это.

	normal = Hash.new
	was_not_there = nornal[:zig]
	puts "Wasn't there:"
	p was_not_there

	usually_brown = Hash.new("brown")
	pretending_to_be_there = usuall_brown(:zig)
	puts "Pretending to be there:"
	p pretending_to_be_there

Как можно видеть, где хэш "normal" всегда возвращает nil по умалчанию, указание значения по умолчанию в конструкторе Hashбудет всегда возвращать ваше значение по умолчанию для всех неудачных поисков этого экземпляра хэша.

Два остальных сокращения на самом деле используют удобный метод класса Hash: Hash::[]. Они довольно просты. Первый принимает список параметров выстроенные в пары. Второй принимает только один параметр: массив, содержащий массивы, которые являются сами парами ключ значение.    

Давайте попробуем первую форму:

	chuck_norris = Hash[:punch, 99,:kick, 98, :stops_bullets_with_hands, true]
	p chuck_norris
	
Круто. И легко! Сейчас вы должны использовать вторую форму "new hash" сокращения в этом упражнении. Еще раз, он принимает массив пар ключ-значение. Эти пары ключ-значение будут просто 2-х элементными массивами. Я дам тебе пары ключ-значение, чтобы начать. Твоя задача расширить Hash этим массивом.

	def artax
  	  a = [:punch, 0]
  	  b = [:kick, 72]
  	  c = [:stops_bullets_with_hands, false]
 	  key_value_pairs = [a,b,c]
 	  Hash[key_value_pairs]
	end
	p artax 

