# 6.1 Упорядочим #

## В самом деле, что такое методы? ##

Мы уже говорили о том, как объекты в Ruby являются аналогами объектов в настоящем мире. Мы также уже кратко охватили как они взаимодействуют друг с другом через конструкцию называемую "метод". Поскольку все полезное в программе случается через объекты осуществляющие взаимодействие используя методы, хорошо их понимать очень важно. 

Когда один объект вызывает метод другого, он просто говорит ему что сделать. Метод затем если просто на программном жаргоне, некий объект может сделать для другого.

В примере ниже, мы спрашиваем объект, которое представляет integer 1 дать нам следующее значение в последовательности. Запомните, что в контексте программы, "мы" просто означает текущий объект.

	puts 1.next

Так, подведем итог, объект содержит данные, которые являются тем, чем он есть и методы, которые он может выполнять. Неявным в этом определении является тот факт, что возможности объекта ограничены методами, которые он предоставляет.

## Методы как объекты ##

Методы освобождены от правила "все является объектом". Это означает, что методы предоставляемые любому объекту - сами объекты, и да, вы можете использовать их в качестве таковых.

Все объекты в Ruby предоставляют одноименный метод method, который может использоваться для того, чтобы овладеть любым методом как объектом.

	puts 1.method("next")

Тут мы спросили объект 1 чтобы дать нам экземпляр метода next.

Метод объекта все еще сохраняет связь с объектом, которому он принадлежит, таким образом вы все еще можете вызвать его используя одноименный метод call и он реагирует как обычный вызов этого метода.

Посмотрите сами.

	next_method_object = 1.method("next")
	puts next_method_object.call

Стоит отметить, что в обычном ходе вещей, маловероятно то, что вам нужно будет или следует искать метод объекта и использовать его таким образом.


## Make it so ##

Давайте напишем метод называемый reverse_sign, который принимает один объект - Integer - и меняет положительное значение на отрицательное и наоборот. Мы затем проанализируем это, затем перейдем к твоей практике, напишем твой собственный метод.

	def reverse_sign(an_integer)
	  return 0 - an_integer
	end

	puts reverse_sign(100)
	puts reverse_sign(-5)

Он отлично работает, преобразует 100 в -100 и -5 в 5 просто вычитая данное число из 0.

Давайте немного проанализируем этот пример и затем вы сможете на практике написать свой собственный.

Сначало, обратите внимание на то, что мы используем ключевое слово def чтобы создать метод называемый reverse_sign текущего объекта. Поскольку Ruby не позволяет нам использовать пробелы в именах методов, мы заменяем их с символом нижнего подчеркивания вместо этого. Реккомендуется также то, как соглашение, имена методов должны быть в нижнем регистре(строчными).

Метод reverse_sign принимает один параметр или аргумент. Это просто жаргон для объектов, метод требует от вызывающего объекта, для того чтобы он сделал свою работу. В этом случае это integer. Метод может принимать любое количество параметров(или ничего).

Ключевое слово return указывает объекту, вернуться к объекту, когда метод завершит свою работу. Если ключевое слово return не указано, объект созданный последней строкой в методе автоматически рассматривается как возвращаемое значение. Метод должен всегда возвращать только объект.

В завершение, метод закрыватся используя ключевое слово end. Просто, верно?

	def do_nothing
	end

	puts do_nothing.class

Как видите, даже метод, который совсем ничего не делает и у которого нет return производит объект - nil.
Я распечатал имя класса потому что печатая nil возвращается пустая строка, таким образом вы ничего не увидите.

Будьте осторожны когда используете return - вызывая return происходит также выход из метода в том месте. Код метода, находящийся за оператором return не выполняется.

	def demostrate_early_return
	  return
	  puts "You will never see this, because we never get here."
        end
	
	puts demostrate_early_return.class

Последний пример показывает две вещи:

1. return выходит из метода; оператор puts приходит сразу после него и никогда не запускается.
2. вызов return без указания объекта при выходе, nil вернется по умолчанию.

Отличная практика это также избегать использовать return везде или всегда использовать return в последней строке метода( что в действительности тоже самое).
Наличие метода выхода в середине всегда удивляет, будучи последовательным в таком виде, код становится легче, чтобы его понимать.

## Телепортируй меня, Скотт ##

Ваша очередь. Напишите метод называемый add_two который прибавляет 2 к любому числу переданного ему и возвращает результат. Да, пожалуйста, не стесняйтесь пробовать используя next в дополнение к более ясному направление просто добавим число 2 к входящему числу.

Более тонкий урок мы можем извлечь из этого упражнения - особенно если вы принялись за эту работу используя сложение также как next, а именно:

1.Как и любой использующий метод, вы обычно не заботитесь о том, как это работает, просто это работает.
2.Как автор этого метода, вы свободны чтобы изменять его внутреннюю реализацию до тех пор пока он производить тот же результат. Переключитесь от сложения к методу next и вернитесь снова - мастер будет счастлив в любом случае.

	  
                                                                                                          
