# 8.2 Модули как пространства имен #

## Конфликтный путь ##

Пространства имен это способ объединения логически связанных объектов вместе. Модули служат удобным инструментом для этого. Это позволяет классам и модулям с 
одинаковыми именами, приводящие к конфликтам, сосуществовать избегая конфликтов. Понимай так, будто сохраняешь различные файлы с одинаковыми именами в раздельных каталогах твоей файловой системы.

Модули также могут содержать классы. В этом примере, мы попытаемся определить класс Array в модуле Perimeter прошлого урока. Обратите внимание он не совсем не  влияет на класс Array Ruby.

	module Perimeter
	  class Array
	    def initialize
	      @size = 400
	    end
	  end
	end

	our_array = Perimeter::Array.new
	ruby_array = Array.new

	p our_array.class
	p ruby_array.class

Мы имеем эти два класса паралелльно друг с другом. Это возможно потому что наша версия класса Array находится под модулем Perimeter.

:: это операто поиска констант, который ищет константу Array только в модуле Perimeter.

Что случится когда у нашего класса не будет пространства имен?

 	class Array
	  def initialize
	    @size = 400
	  end
	end

	our_array = Array.new
	p our_array.class

Т.к. Ruby классы открыты, делая таким образом просто расширяется класс Array глобально на все программу, что опасно и конечно не наше намеренное поведение.

Примеры выше, выдуманы для простоты. Настоящая проблема в том, что пространства имен решают проблему, когда происходит загрузка библиотек. Если твоя программа связывает библиотеки, написанные разными авторами, часто случается, что там могут быть классы и модули, определенные тем же именем.

Мы предположим, что эти две библиотеки gym и dojo имеют классы, как показано в коментариях на ними.

	# class Push
	#   def up
	#     40
	#   end
	# end
	require "gym" # up returns 40
	gym_push = Push.new
	p gym_push.up

	# class Push
	#   def up
	#     30
	#   end
	# end
	require "dojo" # up returns 30
	dojo_push = Push.new
	p dojo_push.up


Т.к. dojo библиотека загружается после gym, происходит переопределение класса Push модуля gym и повсеместно создаются экземпляры класса Push описанных в dojo.

Решение этой проблемы это обернуть эти классы в соответствующие пространства имен используя модули.

	# module Gym
	#   class Push
	#     def up
	#       40
	#     end
	#   end
	# end
	require "gym"

	# module Dojo
	#   class Push
	#     def up
	#       30
	#     end
	#   end
	# end
	require "dojo"

	dojo_push = Dojo::Push.new
	p dojo_push.up

	gym_push = Gym::Push.new
	p gym_push.up

Когда ты создаешь библиотеку Ruby, хорошей практикой является оборачивать в пространство имен твой код именем твоей библиотеки или проекта.

## Поиск констант ##

Мы использовали оператор поиска констант ( :: ) в предыдущем разделе, чтобы захватить наш класс в модуль. Как видно из названия, вы можете захватить любую константу используя этот оператор и не только классы.

	module Dojo
	  A = 4
	  module Kata
	  	B = 8
	    module Roulette
	      class ScopeIn
	        def push
	          15
	        end
	      end
	    end
	  end
	end

	A = 16
	B = 23
	C = 42

	puts "A - #{A}"
	puts "Dojo::A - #{Dojo::A}"

	puts

	puts "B - #{B}"
	puts "Dojo::Kata::B - #{Dojo::Kata::B}"

	puts

	puts "C - #{C}"
	puts "Dojo::Kata::Roulette::ScopeIn.new.push - #{Dojo::Kata::Roulette::ScopeIn.new.push}"

Несколько вещей происходит в примере выше.

> Константа A находится в пределах Dojo и получает доступ к ней через :: работает как и ожидалось.
> То же для константы B, которая вложена дальше внутрь Kata.
> Класс ScropIn вложен еще глубже внутрь Roulette, метод которого возвращает 15.


Это говорит нам о двух важных вещах. Первое, мы можем вложить константу так глубоко как мы хотим. Второе, мы не ограничены только классами и модулями.

Вам дана библиотека, называемая RubyMonk. Она содержит модуль Parser, который определяет класс CodeParser. Напишите другой класс TextParser в этом же пространстве имен, которая разбивает строку и возвращает массив символов в верхнем регистре.

	module RubyMonk
	  module Parser
	    class TextParser
	      def self.parse(str)
	        # define method
	        str.upcase.chars.to_a
	      end
	    end
	  end
	end	

Если вы добавите к началу :: без родителя, обзор происходит на самом верхнем уровне. В этом упражнении, измените push, чтобы он возвращал 10 согласно тому A = 10 на самом верхнем уровне, вне модуля Kata.

Использование модулей и пространств имен это стандартный способ организации библиотек в Ruby. Хорошая практика помнить об этом при написании модулей.


